{"version":3,"names":["_core","require","_traverse","_helperReplaceSupers","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_helperAnnotateAsPure","_helperSkipTransparentExpressionWrappers","ts","newHelpers","file","availableHelper","buildPrivateNamesMap","className","privateFieldsAsSymbolsOrProperties","props","privateNamesMap","Map","classBrandId","prop","isPrivate","name","node","key","id","update","get","isMethod","isProperty","isStatic","static","initAdded","scope","generateUidIdentifier","method","set","isClassPrivateMethod","kind","body","$","length","t","isReturnStatement","isCallExpression","argument","arguments","isThisExpression","isIdentifier","callee","getId","cloneNode","getterDeclared","params","isExpressionStatement","expression","setId","setterDeclared","methodId","buildPrivateNamesNodes","privateFieldsAsProperties","privateFieldsAsSymbols","state","initNodes","injectedIds","Set","value","isGetterOrSetter","init","callExpression","addHelper","stringLiteral","identifier","has","add","newExpression","annotateAsPure","push","template","statement","ast","privateNameVisitorFactory","visitor","nestedVisitor","visitors","environmentVisitor","Object","assign","privateNameVisitor","Class","path","visiblePrivateNames","redeclared","delete","traverse","skipKey","PrivateName","noDocumentAll","parentPath","isMemberExpression","property","isOptionalMemberExpression","includes","handle","unshadow","innerBinding","_scope","hasBinding","bindingIdentifierEquals","rename","parent","buildCheckInRHS","rhs","inRHSIsObject","privateInVisitor","BinaryExpression","operator","left","right","isPrivateName","classRef","replaceWith","readOnlyError","writeOnlyError","console","warn","buildUndefinedNode","buildStaticPrivateFieldAccess","expr","noUninitializedPrivateFieldAccess","memberExpression","autoInherits","fn","member","inherits","apply","privateNameHandlerSpec","memoise","count","object","memo","maybeGenerateMemoised","memoiser","receiver","privateName","cloneId","helperName","skipCheck","err","sequenceExpression","boundGet","assignmentExpression","destructureSet","helper","_unused","Error","getCall","ref","pop","setCall","buildCodeFrameError","args","computed","arrayExpression","slice","call","optimiseCall","optionalCall","privateNameHandlerLoose","BASE","REF","PROP","simpleSet","optionalCallExpression","transformPrivateNamesUsage","size","handler","memberExpressionToFunctions","buildPrivateFieldInitLoose","inheritPropComments","buildPrivateInstanceFieldInitSpec","inheritLoc","expressionStatement","thisExpression","buildPrivateStaticFieldInitSpec","variableDeclaration","variableDeclarator","buildPrivateStaticFieldInitSpecOld","buildPrivateMethodInitLoose","buildPrivateInstanceMethodInitSpec","buildPrivateAccessorInitialization","buildPrivateInstanceMethodInitialization","buildPublicFieldInitLoose","isLiteral","buildPublicFieldInitSpec","buildPrivateStaticMethodInitLoose","buildPrivateMethodDeclaration","generator","async","isGetter","isSetter","thisArg","thisRef","argumentsPath","thisContextVisitor","argumentsId","unshift","declId","functionDeclaration","Identifier","UnaryExpression","skipTransparentExprWrapperNodes","booleanLiteral","ThisExpression","needsClassRef","MetaProperty","meta","innerReferencesVisitor","ReferencedIdentifier","replaceThisContext","innerBindingRef","_state$thisRef","isNameOrLength","type","inheritLeadingComments","inheritInnerComments","original","start","end","loc","buildFieldsInitNodes","superRef","setPublicClassFields","constantSuper","classRefFlags","injectSuperRef","staticNodes","instanceNodes","lastInstanceNodeReturnsThis","pureStaticNodes","classBindingNode","getSuperRef","generateUidIdentifierBasedOnNode","classRefForInnerBinding","isClassProperty","assertFieldTransformed","isStaticBlock","isInstance","isPublic","isField","ReplaceSupers","methodPath","refToPreserve","getObjectRef","replace","replaced","blockBody","inheritsComments","filter","Boolean","wrapClass","leadingComments","remove","superClass","isClassExpression"],"sources":["../src/fields.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { File, NodePath, Visitor, Scope } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type {\n  Handler,\n  HandlerState,\n} from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\nimport * as ts from \"./typescript.ts\";\n\ninterface PrivateNameMetadata {\n  id: t.Identifier;\n  static: boolean;\n  method: boolean;\n  getId?: t.Identifier;\n  setId?: t.Identifier;\n  methodId?: t.Identifier;\n  initAdded?: boolean;\n  getterDeclared?: boolean;\n  setterDeclared?: boolean;\n}\n\ntype PrivateNamesMapGeneric<V> = Map<string, V>;\n\ntype PrivateNamesMap = PrivateNamesMapGeneric<PrivateNameMetadata>;\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var newHelpers = (file: File) => {\n    if (!process.env.IS_PUBLISH) {\n      const { comments } = file.ast;\n      // This is needed for the test in\n      // babel-plugin-transform-class-properties/test/fixtures/regression/old-helpers\n      if (comments?.some(c => c.value.includes(\"@force-old-private-helpers\"))) {\n        return false;\n      }\n    }\n    return file.availableHelper(\"classPrivateFieldGet2\");\n  };\n}\n\nexport function buildPrivateNamesMap(\n  className: string,\n  privateFieldsAsSymbolsOrProperties: boolean,\n  props: PropPath[],\n  file: File,\n) {\n  const privateNamesMap: PrivateNamesMap = new Map();\n  let classBrandId: t.Identifier;\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const { name } = prop.node.key.id;\n      let update: PrivateNameMetadata = privateNamesMap.get(name);\n      if (!update) {\n        const isMethod = !prop.isProperty();\n        const isStatic = prop.node.static;\n        let initAdded = false;\n        let id: t.Identifier;\n        if (\n          !privateFieldsAsSymbolsOrProperties &&\n          (process.env.BABEL_8_BREAKING || newHelpers(file)) &&\n          isMethod &&\n          !isStatic\n        ) {\n          initAdded = !!classBrandId;\n          classBrandId ??= prop.scope.generateUidIdentifier(\n            `${className}_brand`,\n          );\n          id = classBrandId;\n        } else {\n          id = prop.scope.generateUidIdentifier(name);\n        }\n        update = { id, static: isStatic, method: isMethod, initAdded };\n        privateNamesMap.set(name, update);\n      }\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          const { body } = prop.node.body;\n          let $: t.Node;\n          if (\n            // If we have\n            //   get #foo() { return _some_fn(this); }\n            // we can use _some_fn directly.\n            body.length === 1 &&\n            t.isReturnStatement(($ = body[0])) &&\n            t.isCallExpression(($ = $.argument)) &&\n            $.arguments.length === 1 &&\n            t.isThisExpression($.arguments[0]) &&\n            t.isIdentifier(($ = $.callee))\n          ) {\n            update.getId = t.cloneNode($);\n            update.getterDeclared = true;\n          } else {\n            update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n          }\n        } else if (prop.node.kind === \"set\") {\n          const { params } = prop.node;\n          const { body } = prop.node.body;\n          let $: t.Node;\n          if (\n            // If we have\n            //   set #foo(val) { _some_fn(this, val); }\n            // we can use _some_fn directly.\n            body.length === 1 &&\n            t.isExpressionStatement(($ = body[0])) &&\n            t.isCallExpression(($ = $.expression)) &&\n            $.arguments.length === 2 &&\n            t.isThisExpression($.arguments[0]) &&\n            t.isIdentifier($.arguments[1], {\n              name: (params[0] as t.Identifier).name,\n            }) &&\n            t.isIdentifier(($ = $.callee))\n          ) {\n            update.setId = t.cloneNode($);\n            update.setterDeclared = true;\n          } else {\n            update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n          }\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\n\nexport function buildPrivateNamesNodes(\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties: boolean,\n  privateFieldsAsSymbols: boolean,\n  state: File,\n) {\n  const initNodes: t.Statement[] = [];\n\n  const injectedIds = new Set<string>();\n\n  for (const [name, value] of privateNamesMap) {\n    // - When the privateFieldsAsProperties assumption is enabled,\n    //   both static and instance fields are transpiled using a\n    //   secret non-enumerable property. Hence, we also need to generate that\n    //   key (using the classPrivateFieldLooseKey helper).\n    // - When the privateFieldsAsSymbols assumption is enabled,\n    //   both static and instance fields are transpiled using a\n    //   unique Symbol to define a non-enumerable property.\n    // - In spec mode, only instance fields need a \"private name\" initializer\n    //   because static fields are directly assigned to a variable in the\n    //   buildPrivateStaticFieldInitSpec function.\n    const { static: isStatic, method: isMethod, getId, setId } = value;\n    const isGetterOrSetter = getId || setId;\n    const id = t.cloneNode(value.id);\n\n    let init: t.Expression;\n\n    if (privateFieldsAsProperties) {\n      init = t.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [\n        t.stringLiteral(name),\n      ]);\n    } else if (privateFieldsAsSymbols) {\n      init = t.callExpression(t.identifier(\"Symbol\"), [t.stringLiteral(name)]);\n    } else if (!isStatic) {\n      if (injectedIds.has(id.name)) continue;\n      injectedIds.add(id.name);\n\n      init = t.newExpression(\n        t.identifier(\n          isMethod &&\n            (process.env.BABEL_8_BREAKING ||\n              !isGetterOrSetter ||\n              newHelpers(state))\n            ? \"WeakSet\"\n            : \"WeakMap\",\n        ),\n        [],\n      );\n    }\n\n    if (init) {\n      if (!privateFieldsAsSymbols) {\n        annotateAsPure(init);\n      }\n      initNodes.push(template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n\n  return initNodes;\n}\n\nexport interface PrivateNameVisitorState<V> {\n  privateNamesMap: PrivateNamesMapGeneric<V>;\n  redeclared?: string[];\n}\n\n// Traverses the class scope, handling private name references. If an inner\n// class redeclares the same private name, it will hand off traversal to the\n// restricted visitor (which doesn't traverse the inner class's inner scope).\nexport function privateNameVisitorFactory<S, V>(\n  visitor: Visitor<PrivateNameVisitorState<V & PrivateNameMetadata> & S>,\n) {\n  // Traverses the outer portion of a class, without touching the class's inner\n  // scope, for private names.\n  const nestedVisitor = visitors.environmentVisitor({ ...visitor });\n\n  const privateNameVisitor: Visitor<\n    PrivateNameVisitorState<V & PrivateNameMetadata> & S\n  > = {\n    ...visitor,\n\n    Class(path) {\n      const { privateNamesMap } = this;\n      const body = path.get(\"body.body\");\n\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const { name } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      // If the class doesn't redeclare any private fields, we can continue with\n      // our overall traversal.\n      if (!redeclared.length) {\n        return;\n      }\n\n      // This class redeclares some private field. We need to process the outer\n      // environment with access to all the outer privates, then we can process\n      // the inner environment with only the still-visible outer privates.\n      path.get(\"body\").traverse(nestedVisitor, {\n        ...this,\n        redeclared,\n      });\n      path.traverse(privateNameVisitor, {\n        ...this,\n        privateNamesMap: visiblePrivateNames,\n      });\n\n      // We'll eventually hit this class node again with the overall Class\n      // Features visitor, which'll process the redeclared privates.\n      path.skipKey(\"body\");\n    },\n  };\n\n  return privateNameVisitor;\n}\n\ninterface PrivateNameState {\n  privateNamesMap: PrivateNamesMap;\n  classRef: t.Identifier;\n  file: File;\n  noDocumentAll: boolean;\n  noUninitializedPrivateFieldAccess: boolean;\n  innerBinding?: t.Identifier;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory<\n  HandlerState<PrivateNameState> & PrivateNameState,\n  PrivateNameMetadata\n>({\n  PrivateName(path, { noDocumentAll }) {\n    const { privateNamesMap, redeclared } = this;\n    const { node, parentPath } = path;\n\n    if (\n      !parentPath.isMemberExpression({ property: node }) &&\n      !parentPath.isOptionalMemberExpression({ property: node })\n    ) {\n      return;\n    }\n    const { name } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared?.includes(name)) return;\n\n    this.handle(parentPath, noDocumentAll);\n  },\n});\n\n// rename all bindings that shadows innerBinding\nfunction unshadow(\n  name: string,\n  scope: Scope,\n  innerBinding: t.Identifier | undefined,\n) {\n  // in some cases, scope.getBinding(name) === undefined\n  // so we check hasBinding to avoid keeping looping\n  // see: https://github.com/babel/babel/pull/13656#discussion_r686030715\n  while (\n    scope?.hasBinding(name) &&\n    !scope.bindingIdentifierEquals(name, innerBinding)\n  ) {\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\n\nexport function buildCheckInRHS(\n  rhs: t.Expression,\n  file: File,\n  inRHSIsObject?: boolean,\n) {\n  if (inRHSIsObject || !file.availableHelper?.(\"checkInRHS\")) return rhs;\n  return t.callExpression(file.addHelper(\"checkInRHS\"), [rhs]);\n}\n\nconst privateInVisitor = privateNameVisitorFactory<\n  {\n    classRef: t.Identifier;\n    file: File;\n    innerBinding?: t.Identifier;\n    privateFieldsAsProperties: boolean;\n  },\n  PrivateNameMetadata\n>({\n  BinaryExpression(path, { file }) {\n    const { operator, left, right } = path.node;\n    if (operator !== \"in\") return;\n    if (!t.isPrivateName(left)) return;\n\n    const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;\n\n    const { name } = left.id;\n\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared?.includes(name)) return;\n\n    // if there are any local variable shadowing classRef, unshadow it\n    // see #12960\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n\n    if (privateFieldsAsProperties) {\n      const { id } = privateNamesMap.get(name);\n      path.replaceWith(template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(\n          right,\n          file,\n        )}, ${t.cloneNode(id)})\n      `);\n      return;\n    }\n\n    const { id, static: isStatic } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(\n        template.expression.ast`${buildCheckInRHS(\n          right,\n          file,\n        )} === ${t.cloneNode(this.classRef)}`,\n      );\n      return;\n    }\n\n    path.replaceWith(\n      template.expression.ast`${t.cloneNode(id)}.has(${buildCheckInRHS(\n        right,\n        file,\n      )})`,\n    );\n  },\n});\n\ninterface Receiver {\n  receiver(\n    this: HandlerState<PrivateNameState> & PrivateNameState,\n    member: NodePath<t.MemberExpression | t.OptionalMemberExpression>,\n  ): t.Expression;\n}\n\nfunction readOnlyError(file: File, name: string) {\n  return t.callExpression(file.addHelper(\"readOnlyError\"), [\n    t.stringLiteral(`#${name}`),\n  ]);\n}\n\nfunction writeOnlyError(file: File, name: string) {\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    !file.availableHelper(\"writeOnlyError\")\n  ) {\n    console.warn(\n      `@babel/helpers is outdated, update it to silence this warning.`,\n    );\n    return t.buildUndefinedNode();\n  }\n  return t.callExpression(file.addHelper(\"writeOnlyError\"), [\n    t.stringLiteral(`#${name}`),\n  ]);\n}\n\nfunction buildStaticPrivateFieldAccess<N extends t.Expression>(\n  expr: N,\n  noUninitializedPrivateFieldAccess: boolean,\n) {\n  if (noUninitializedPrivateFieldAccess) return expr;\n  return t.memberExpression(expr, t.identifier(\"_\"));\n}\n\nfunction autoInherits<\n  Member extends { node: t.Node },\n  Result extends t.Node,\n  Fn extends (member: Member, ...args: unknown[]) => Result,\n>(fn: Fn): Fn {\n  return function (this: ThisParameterType<Fn>, member) {\n    return t.inherits(fn.apply(this, arguments as any), member.node);\n  } as Fn;\n}\n\nconst privateNameHandlerSpec: Handler<PrivateNameState & Receiver> & Receiver =\n  {\n    memoise(member, count) {\n      const { scope } = member;\n      const { object } = member.node as { object: t.Expression };\n\n      const memo = scope.maybeGenerateMemoised(object);\n      if (!memo) {\n        return;\n      }\n\n      this.memoiser.set(object, memo, count);\n    },\n\n    receiver(member) {\n      const { object } = member.node as { object: t.Expression };\n\n      if (this.memoiser.has(object)) {\n        return t.cloneNode(this.memoiser.get(object));\n      }\n\n      return t.cloneNode(object);\n    },\n\n    get: autoInherits(function (member) {\n      const {\n        classRef,\n        privateNamesMap,\n        file,\n        innerBinding,\n        noUninitializedPrivateFieldAccess,\n      } = this;\n      const privateName = member.node.property as t.PrivateName;\n      const { name } = privateName.id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        methodId,\n        getId,\n        setId,\n      } = privateNamesMap.get(name);\n      const isGetterOrSetter = getId || setId;\n\n      const cloneId = (id: t.Identifier) =>\n        t.inherits(t.cloneNode(id), privateName);\n\n      if (isStatic) {\n        // if there are any local variable shadowing classRef, unshadow it\n        // see #12960\n        unshadow(classRef.name, member.scope, innerBinding);\n\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          // NOTE: This package has a peerDependency on @babel/core@^7.0.0, but these\n          // helpers have been introduced in @babel/helpers@7.1.0.\n          const helperName =\n            isMethod && !isGetterOrSetter\n              ? \"classStaticPrivateMethodGet\"\n              : \"classStaticPrivateFieldSpecGet\";\n\n          return t.callExpression(file.addHelper(helperName), [\n            this.receiver(member),\n            t.cloneNode(classRef),\n            cloneId(id),\n          ]);\n        }\n\n        const receiver = this.receiver(member);\n        const skipCheck =\n          t.isIdentifier(receiver) && receiver.name === classRef.name;\n\n        if (!isMethod) {\n          if (skipCheck) {\n            return buildStaticPrivateFieldAccess(\n              cloneId(id),\n              noUninitializedPrivateFieldAccess,\n            );\n          }\n\n          return buildStaticPrivateFieldAccess(\n            t.callExpression(file.addHelper(\"assertClassBrand\"), [\n              t.cloneNode(classRef),\n              receiver,\n              cloneId(id),\n            ]),\n            noUninitializedPrivateFieldAccess,\n          );\n        }\n\n        if (getId) {\n          if (skipCheck) {\n            return t.callExpression(cloneId(getId), [receiver]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateGetter\"), [\n            t.cloneNode(classRef),\n            receiver,\n            cloneId(getId),\n          ]);\n        }\n\n        if (setId) {\n          const err = t.buildUndefinedNode(); // TODO: writeOnlyError(file, name)\n          if (skipCheck) return err;\n          return t.sequenceExpression([\n            t.callExpression(file.addHelper(\"assertClassBrand\"), [\n              t.cloneNode(classRef),\n              receiver,\n            ]),\n            err,\n          ]);\n        }\n\n        if (skipCheck) return cloneId(id);\n        return t.callExpression(file.addHelper(\"assertClassBrand\"), [\n          t.cloneNode(classRef),\n          receiver,\n          cloneId(id),\n        ]);\n      }\n\n      if (isMethod) {\n        if (isGetterOrSetter) {\n          if (!getId) {\n            return t.sequenceExpression([\n              this.receiver(member),\n              writeOnlyError(file, name),\n            ]);\n          }\n          if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n            return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n              this.receiver(member),\n              cloneId(id),\n            ]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateGetter\"), [\n            t.cloneNode(id),\n            this.receiver(member),\n            cloneId(getId),\n          ]);\n        }\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          return t.callExpression(file.addHelper(\"classPrivateMethodGet\"), [\n            this.receiver(member),\n            t.cloneNode(id),\n            cloneId(methodId),\n          ]);\n        }\n        return t.callExpression(file.addHelper(\"assertClassBrand\"), [\n          t.cloneNode(id),\n          this.receiver(member),\n          cloneId(methodId),\n        ]);\n      }\n      if (process.env.BABEL_8_BREAKING || newHelpers(file)) {\n        return t.callExpression(file.addHelper(\"classPrivateFieldGet2\"), [\n          cloneId(id),\n          this.receiver(member),\n        ]);\n      }\n\n      return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n        this.receiver(member),\n        cloneId(id),\n      ]);\n    }),\n\n    boundGet(member) {\n      this.memoise(member, 1);\n\n      return t.callExpression(\n        t.memberExpression(this.get(member), t.identifier(\"bind\")),\n        [this.receiver(member)],\n      );\n    },\n\n    set: autoInherits(function (member, value) {\n      const {\n        classRef,\n        privateNamesMap,\n        file,\n        noUninitializedPrivateFieldAccess,\n      } = this;\n      const privateName = member.node.property as t.PrivateName;\n      const { name } = privateName.id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        setId,\n        getId,\n      } = privateNamesMap.get(name);\n      const isGetterOrSetter = getId || setId;\n\n      const cloneId = (id: t.Identifier) =>\n        t.inherits(t.cloneNode(id), privateName);\n\n      if (isStatic) {\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          const helperName =\n            isMethod && !isGetterOrSetter\n              ? \"classStaticPrivateMethodSet\"\n              : \"classStaticPrivateFieldSpecSet\";\n\n          return t.callExpression(file.addHelper(helperName), [\n            this.receiver(member),\n            t.cloneNode(classRef),\n            cloneId(id),\n            value,\n          ]);\n        }\n\n        const receiver = this.receiver(member);\n        const skipCheck =\n          t.isIdentifier(receiver) && receiver.name === classRef.name;\n\n        if (isMethod && !setId) {\n          const err = readOnlyError(file, name);\n          if (skipCheck) return t.sequenceExpression([value, err]);\n          return t.sequenceExpression([\n            value,\n            t.callExpression(file.addHelper(\"assertClassBrand\"), [\n              t.cloneNode(classRef),\n              receiver,\n            ]),\n            readOnlyError(file, name),\n          ]);\n        }\n\n        if (setId) {\n          if (skipCheck) {\n            return t.callExpression(t.cloneNode(setId), [receiver, value]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateSetter\"), [\n            t.cloneNode(classRef),\n            cloneId(setId),\n            receiver,\n            value,\n          ]);\n        }\n        return t.assignmentExpression(\n          \"=\",\n          buildStaticPrivateFieldAccess(\n            cloneId(id),\n            noUninitializedPrivateFieldAccess,\n          ),\n          skipCheck\n            ? value\n            : t.callExpression(file.addHelper(\"assertClassBrand\"), [\n                t.cloneNode(classRef),\n                receiver,\n                value,\n              ]),\n        );\n      }\n      if (isMethod) {\n        if (setId) {\n          if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n            return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n              this.receiver(member),\n              cloneId(id),\n              value,\n            ]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateSetter\"), [\n            t.cloneNode(id),\n            cloneId(setId),\n            this.receiver(member),\n            value,\n          ]);\n        }\n        return t.sequenceExpression([\n          this.receiver(member),\n          value,\n          readOnlyError(file, name),\n        ]);\n      }\n\n      if (process.env.BABEL_8_BREAKING || newHelpers(file)) {\n        return t.callExpression(file.addHelper(\"classPrivateFieldSet2\"), [\n          cloneId(id),\n          this.receiver(member),\n          value,\n        ]);\n      }\n\n      return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n        this.receiver(member),\n        cloneId(id),\n        value,\n      ]);\n    }),\n\n    destructureSet(member) {\n      const {\n        classRef,\n        privateNamesMap,\n        file,\n        noUninitializedPrivateFieldAccess,\n      } = this;\n      const privateName = member.node.property as t.PrivateName;\n      const { name } = privateName.id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        setId,\n      } = privateNamesMap.get(name);\n\n      const cloneId = (id: t.Identifier) =>\n        t.inherits(t.cloneNode(id), privateName);\n\n      if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n        if (isStatic) {\n          try {\n            // classStaticPrivateFieldDestructureSet was introduced in 7.13.10\n            // eslint-disable-next-line no-var\n            var helper = file.addHelper(\n              \"classStaticPrivateFieldDestructureSet\",\n            );\n          } catch {\n            throw new Error(\n              \"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" +\n                \"please update @babel/helpers to the latest version.\",\n            );\n          }\n          return t.memberExpression(\n            t.callExpression(helper, [\n              this.receiver(member),\n              t.cloneNode(classRef),\n              cloneId(id),\n            ]),\n            t.identifier(\"value\"),\n          );\n        }\n\n        return t.memberExpression(\n          t.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [\n            this.receiver(member),\n            cloneId(id),\n          ]),\n          t.identifier(\"value\"),\n        );\n      }\n\n      if (isMethod && !setId) {\n        return t.memberExpression(\n          t.sequenceExpression([\n            // @ts-ignore(Babel 7 vs Babel 8) member.node.object is not t.Super\n            member.node.object,\n            readOnlyError(file, name),\n          ]),\n          t.identifier(\"_\"),\n        );\n      }\n\n      if (isStatic && !isMethod) {\n        const getCall = this.get(member);\n        if (\n          !noUninitializedPrivateFieldAccess ||\n          !t.isCallExpression(getCall)\n        ) {\n          return getCall;\n        }\n        const ref = getCall.arguments.pop();\n        getCall.arguments.push(template.expression.ast`(_) => ${ref} = _`);\n        return t.memberExpression(\n          t.callExpression(file.addHelper(\"toSetter\"), [getCall]),\n          t.identifier(\"_\"),\n        );\n      }\n\n      const setCall = this.set(member, t.identifier(\"_\"));\n      if (\n        !t.isCallExpression(setCall) ||\n        !t.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {\n          name: \"_\",\n        })\n      ) {\n        throw member.buildCodeFrameError(\n          \"Internal Babel error while compiling this code. This is a Babel bug. \" +\n            \"Please report it at https://github.com/babel/babel/issues.\",\n        );\n      }\n\n      // someHelper(foo, bar, _) -> someHelper, [foo, bar]\n      // aFn.call(foo, bar, _) -> aFn, [bar], foo\n      let args: t.Expression[];\n      if (\n        t.isMemberExpression(setCall.callee, { computed: false }) &&\n        t.isIdentifier(setCall.callee.property) &&\n        setCall.callee.property.name === \"call\"\n      ) {\n        args = [\n          // @ts-ignore(Babel 7 vs Babel 8) member.node.object is not t.Super\n          setCall.callee.object,\n          t.arrayExpression(\n            // Remove '_'\n            (setCall.arguments as t.Expression[]).slice(1, -1),\n          ),\n          setCall.arguments[0] as t.Expression,\n        ];\n      } else {\n        args = [\n          setCall.callee as t.Expression,\n          t.arrayExpression(\n            // Remove '_'\n            (setCall.arguments as t.Expression[]).slice(0, -1),\n          ),\n        ];\n      }\n\n      return t.memberExpression(\n        t.callExpression(file.addHelper(\"toSetter\"), args),\n        t.identifier(\"_\"),\n      );\n    },\n\n    call(member, args: (t.Expression | t.SpreadElement)[]) {\n      // The first access (the get) should do the memo assignment.\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, false);\n    },\n\n    optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, true);\n    },\n\n    delete() {\n      throw new Error(\n        \"Internal Babel error: deleting private elements is a parsing error.\",\n      );\n    },\n  };\n\nconst privateNameHandlerLoose: Handler<PrivateNam